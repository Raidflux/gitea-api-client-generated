// Code generated by go-swagger; DO NOT EDIT.

package repository

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"io"

	"github.com/go-openapi/runtime"
	httptransport "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"
)

// New creates a new repository API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

// New creates a new repository API client with basic auth credentials.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - user: user for basic authentication header.
// - password: password for basic authentication header.
func NewClientWithBasicAuth(host, basePath, scheme, user, password string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BasicAuth(user, password)
	return &Client{transport: transport, formats: strfmt.Default}
}

// New creates a new repository API client with a bearer token for authentication.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - bearerToken: bearer token for Bearer authentication header.
func NewClientWithBearerToken(host, basePath, scheme, bearerToken string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BearerToken(bearerToken)
	return &Client{transport: transport, formats: strfmt.Default}
}

/*
Client for repository API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption may be used to customize the behavior of Client methods.
type ClientOption func(*runtime.ClientOperation)

// This client is generated with a few options you might find useful for your swagger spec.
//
// Feel free to add you own set of options.

// WithContentType allows the client to force the Content-Type header
// to negotiate a specific Consumer from the server.
//
// You may use this option to set arbitrary extensions to your MIME media type.
func WithContentType(mime string) ClientOption {
	return func(r *runtime.ClientOperation) {
		r.ConsumesMediaTypes = []string{mime}
	}
}

// WithContentTypeApplicationJSON sets the Content-Type header to "application/json".
func WithContentTypeApplicationJSON(r *runtime.ClientOperation) {
	r.ConsumesMediaTypes = []string{"application/json"}
}

// WithContentTypeApplicationOctetStream sets the Content-Type header to "application/octet-stream".
func WithContentTypeApplicationOctetStream(r *runtime.ClientOperation) {
	r.ConsumesMediaTypes = []string{"application/octet-stream"}
}

// WithContentTypeMultipartFormData sets the Content-Type header to "multipart/form-data".
func WithContentTypeMultipartFormData(r *runtime.ClientOperation) {
	r.ConsumesMediaTypes = []string{"multipart/form-data"}
}

// WithContentTypeTextPlain sets the Content-Type header to "text/plain".
func WithContentTypeTextPlain(r *runtime.ClientOperation) {
	r.ConsumesMediaTypes = []string{"text/plain"}
}

// WithAccept allows the client to force the Accept header
// to negotiate a specific Producer from the server.
//
// You may use this option to set arbitrary extensions to your MIME media type.
func WithAccept(mime string) ClientOption {
	return func(r *runtime.ClientOperation) {
		r.ProducesMediaTypes = []string{mime}
	}
}

// WithAcceptApplicationJSON sets the Accept header to "application/json".
func WithAcceptApplicationJSON(r *runtime.ClientOperation) {
	r.ProducesMediaTypes = []string{"application/json"}
}

// WithAcceptApplicationOctetStream sets the Accept header to "application/octet-stream".
func WithAcceptApplicationOctetStream(r *runtime.ClientOperation) {
	r.ProducesMediaTypes = []string{"application/octet-stream"}
}

// WithAcceptTextHTML sets the Accept header to "text/html".
func WithAcceptTextHTML(r *runtime.ClientOperation) {
	r.ProducesMediaTypes = []string{"text/html"}
}

// WithAcceptTextPlain sets the Accept header to "text/plain".
func WithAcceptTextPlain(r *runtime.ClientOperation) {
	r.ProducesMediaTypes = []string{"text/plain"}
}

// ClientService is the interface for Client methods
type ClientService interface {
	GetAnnotatedTag(params *GetAnnotatedTagParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetAnnotatedTagOK, error)

	GetBlob(params *GetBlobParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetBlobOK, error)

	GetTree(params *GetTreeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetTreeOK, error)

	ListActionTasks(params *ListActionTasksParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListActionTasksOK, error)

	AcceptRepoTransfer(params *AcceptRepoTransferParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AcceptRepoTransferAccepted, error)

	CreateCurrentUserRepo(params *CreateCurrentUserRepoParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateCurrentUserRepoCreated, error)

	CreateFork(params *CreateForkParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateForkAccepted, error)

	CreateRepoVariable(params *CreateRepoVariableParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateRepoVariableCreated, *CreateRepoVariableNoContent, error)

	DeleteRepoSecret(params *DeleteRepoSecretParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteRepoSecretNoContent, error)

	DeleteRepoVariable(params *DeleteRepoVariableParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteRepoVariableOK, *DeleteRepoVariableCreated, *DeleteRepoVariableNoContent, error)

	GenerateRepo(params *GenerateRepoParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GenerateRepoCreated, error)

	GetRepoVariable(params *GetRepoVariableParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRepoVariableOK, error)

	GetRepoVariablesList(params *GetRepoVariablesListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRepoVariablesListOK, error)

	ListForks(params *ListForksParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListForksOK, error)

	RejectRepoTransfer(params *RejectRepoTransferParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RejectRepoTransferOK, error)

	RepoAddCollaborator(params *RepoAddCollaboratorParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoAddCollaboratorNoContent, error)

	RepoAddPushMirror(params *RepoAddPushMirrorParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoAddPushMirrorOK, error)

	RepoAddTeam(params *RepoAddTeamParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoAddTeamNoContent, error)

	RepoAddTopic(params *RepoAddTopicParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoAddTopicNoContent, error)

	RepoApplyDiffPatch(params *RepoApplyDiffPatchParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoApplyDiffPatchOK, error)

	RepoCancelScheduledAutoMerge(params *RepoCancelScheduledAutoMergeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoCancelScheduledAutoMergeNoContent, error)

	RepoChangeFiles(params *RepoChangeFilesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoChangeFilesCreated, error)

	RepoCheckCollaborator(params *RepoCheckCollaboratorParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoCheckCollaboratorNoContent, error)

	RepoCheckTeam(params *RepoCheckTeamParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoCheckTeamOK, error)

	RepoCompareDiff(params *RepoCompareDiffParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoCompareDiffOK, error)

	RepoCreateBranch(params *RepoCreateBranchParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoCreateBranchCreated, error)

	RepoCreateBranchProtection(params *RepoCreateBranchProtectionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoCreateBranchProtectionCreated, error)

	RepoCreateFile(params *RepoCreateFileParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoCreateFileCreated, error)

	RepoCreateHook(params *RepoCreateHookParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoCreateHookCreated, error)

	RepoCreateKey(params *RepoCreateKeyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoCreateKeyCreated, error)

	RepoCreatePullRequest(params *RepoCreatePullRequestParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoCreatePullRequestCreated, error)

	RepoCreatePullReview(params *RepoCreatePullReviewParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoCreatePullReviewOK, error)

	RepoCreatePullReviewRequests(params *RepoCreatePullReviewRequestsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoCreatePullReviewRequestsCreated, error)

	RepoCreateRelease(params *RepoCreateReleaseParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoCreateReleaseCreated, error)

	RepoCreateReleaseAttachment(params *RepoCreateReleaseAttachmentParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoCreateReleaseAttachmentCreated, error)

	RepoCreateStatus(params *RepoCreateStatusParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoCreateStatusCreated, error)

	RepoCreateTag(params *RepoCreateTagParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoCreateTagOK, error)

	RepoCreateTagProtection(params *RepoCreateTagProtectionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoCreateTagProtectionCreated, error)

	RepoCreateWikiPage(params *RepoCreateWikiPageParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoCreateWikiPageCreated, error)

	RepoDelete(params *RepoDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoDeleteNoContent, error)

	RepoDeleteAvatar(params *RepoDeleteAvatarParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoDeleteAvatarNoContent, error)

	RepoDeleteBranch(params *RepoDeleteBranchParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoDeleteBranchNoContent, error)

	RepoDeleteBranchProtection(params *RepoDeleteBranchProtectionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoDeleteBranchProtectionNoContent, error)

	RepoDeleteCollaborator(params *RepoDeleteCollaboratorParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoDeleteCollaboratorNoContent, error)

	RepoDeleteFile(params *RepoDeleteFileParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoDeleteFileOK, error)

	RepoDeleteGitHook(params *RepoDeleteGitHookParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoDeleteGitHookNoContent, error)

	RepoDeleteHook(params *RepoDeleteHookParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoDeleteHookNoContent, error)

	RepoDeleteKey(params *RepoDeleteKeyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoDeleteKeyNoContent, error)

	RepoDeletePullReview(params *RepoDeletePullReviewParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoDeletePullReviewNoContent, error)

	RepoDeletePullReviewRequests(params *RepoDeletePullReviewRequestsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoDeletePullReviewRequestsNoContent, error)

	RepoDeletePushMirror(params *RepoDeletePushMirrorParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoDeletePushMirrorNoContent, error)

	RepoDeleteRelease(params *RepoDeleteReleaseParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoDeleteReleaseNoContent, error)

	RepoDeleteReleaseAttachment(params *RepoDeleteReleaseAttachmentParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoDeleteReleaseAttachmentNoContent, error)

	RepoDeleteReleaseByTag(params *RepoDeleteReleaseByTagParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoDeleteReleaseByTagNoContent, error)

	RepoDeleteTag(params *RepoDeleteTagParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoDeleteTagNoContent, error)

	RepoDeleteTagProtection(params *RepoDeleteTagProtectionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoDeleteTagProtectionNoContent, error)

	RepoDeleteTeam(params *RepoDeleteTeamParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoDeleteTeamNoContent, error)

	RepoDeleteTopic(params *RepoDeleteTopicParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoDeleteTopicNoContent, error)

	RepoDeleteWikiPage(params *RepoDeleteWikiPageParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoDeleteWikiPageNoContent, error)

	RepoDismissPullReview(params *RepoDismissPullReviewParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoDismissPullReviewOK, error)

	RepoDownloadCommitDiffOrPatch(params *RepoDownloadCommitDiffOrPatchParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoDownloadCommitDiffOrPatchOK, error)

	RepoDownloadPullDiffOrPatch(params *RepoDownloadPullDiffOrPatchParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoDownloadPullDiffOrPatchOK, error)

	RepoEdit(params *RepoEditParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoEditOK, error)

	RepoEditBranchProtection(params *RepoEditBranchProtectionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoEditBranchProtectionOK, error)

	RepoEditGitHook(params *RepoEditGitHookParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoEditGitHookOK, error)

	RepoEditHook(params *RepoEditHookParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoEditHookOK, error)

	RepoEditPullRequest(params *RepoEditPullRequestParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoEditPullRequestCreated, error)

	RepoEditRelease(params *RepoEditReleaseParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoEditReleaseOK, error)

	RepoEditReleaseAttachment(params *RepoEditReleaseAttachmentParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoEditReleaseAttachmentCreated, error)

	RepoEditTagProtection(params *RepoEditTagProtectionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoEditTagProtectionOK, error)

	RepoEditWikiPage(params *RepoEditWikiPageParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoEditWikiPageOK, error)

	RepoGet(params *RepoGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetOK, error)

	RepoGetAllCommits(params *RepoGetAllCommitsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetAllCommitsOK, error)

	RepoGetArchive(params *RepoGetArchiveParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetArchiveOK, error)

	RepoGetAssignees(params *RepoGetAssigneesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetAssigneesOK, error)

	RepoGetBranch(params *RepoGetBranchParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetBranchOK, error)

	RepoGetBranchProtection(params *RepoGetBranchProtectionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetBranchProtectionOK, error)

	RepoGetByID(params *RepoGetByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetByIDOK, error)

	RepoGetCombinedStatusByRef(params *RepoGetCombinedStatusByRefParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetCombinedStatusByRefOK, error)

	RepoGetCommitPullRequest(params *RepoGetCommitPullRequestParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetCommitPullRequestOK, error)

	RepoGetContents(params *RepoGetContentsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetContentsOK, error)

	RepoGetContentsList(params *RepoGetContentsListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetContentsListOK, error)

	RepoGetEditorConfig(params *RepoGetEditorConfigParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetEditorConfigOK, error)

	RepoGetGitHook(params *RepoGetGitHookParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetGitHookOK, error)

	RepoGetHook(params *RepoGetHookParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetHookOK, error)

	RepoGetIssueConfig(params *RepoGetIssueConfigParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetIssueConfigOK, error)

	RepoGetIssueTemplates(params *RepoGetIssueTemplatesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetIssueTemplatesOK, error)

	RepoGetKey(params *RepoGetKeyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetKeyOK, error)

	RepoGetLanguages(params *RepoGetLanguagesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetLanguagesOK, error)

	RepoGetLatestRelease(params *RepoGetLatestReleaseParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetLatestReleaseOK, error)

	RepoGetNote(params *RepoGetNoteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetNoteOK, error)

	RepoGetPullRequest(params *RepoGetPullRequestParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetPullRequestOK, error)

	RepoGetPullRequestByBaseHead(params *RepoGetPullRequestByBaseHeadParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetPullRequestByBaseHeadOK, error)

	RepoGetPullRequestCommits(params *RepoGetPullRequestCommitsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetPullRequestCommitsOK, error)

	RepoGetPullRequestFiles(params *RepoGetPullRequestFilesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetPullRequestFilesOK, error)

	RepoGetPullReview(params *RepoGetPullReviewParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetPullReviewOK, error)

	RepoGetPullReviewComments(params *RepoGetPullReviewCommentsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetPullReviewCommentsOK, error)

	RepoGetPushMirrorByRemoteName(params *RepoGetPushMirrorByRemoteNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetPushMirrorByRemoteNameOK, error)

	RepoGetRawFile(params *RepoGetRawFileParams, authInfo runtime.ClientAuthInfoWriter, writer io.Writer, opts ...ClientOption) (*RepoGetRawFileOK, error)

	RepoGetRawFileOrLFS(params *RepoGetRawFileOrLFSParams, authInfo runtime.ClientAuthInfoWriter, writer io.Writer, opts ...ClientOption) (*RepoGetRawFileOrLFSOK, error)

	RepoGetRelease(params *RepoGetReleaseParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetReleaseOK, error)

	RepoGetReleaseAttachment(params *RepoGetReleaseAttachmentParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetReleaseAttachmentOK, error)

	RepoGetReleaseByTag(params *RepoGetReleaseByTagParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetReleaseByTagOK, error)

	RepoGetRepoPermissions(params *RepoGetRepoPermissionsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetRepoPermissionsOK, error)

	RepoGetReviewers(params *RepoGetReviewersParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetReviewersOK, error)

	RepoGetRunnerRegistrationToken(params *RepoGetRunnerRegistrationTokenParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetRunnerRegistrationTokenOK, error)

	RepoGetSingleCommit(params *RepoGetSingleCommitParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetSingleCommitOK, error)

	RepoGetTag(params *RepoGetTagParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetTagOK, error)

	RepoGetTagProtection(params *RepoGetTagProtectionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetTagProtectionOK, error)

	RepoGetWikiPage(params *RepoGetWikiPageParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetWikiPageOK, error)

	RepoGetWikiPageRevisions(params *RepoGetWikiPageRevisionsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetWikiPageRevisionsOK, error)

	RepoGetWikiPages(params *RepoGetWikiPagesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetWikiPagesOK, error)

	RepoListActionsSecrets(params *RepoListActionsSecretsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoListActionsSecretsOK, error)

	RepoListActivityFeeds(params *RepoListActivityFeedsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoListActivityFeedsOK, error)

	RepoListAllGitRefs(params *RepoListAllGitRefsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoListAllGitRefsOK, error)

	RepoListBranchProtection(params *RepoListBranchProtectionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoListBranchProtectionOK, error)

	RepoListBranches(params *RepoListBranchesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoListBranchesOK, error)

	RepoListCollaborators(params *RepoListCollaboratorsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoListCollaboratorsOK, error)

	RepoListGitHooks(params *RepoListGitHooksParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoListGitHooksOK, error)

	RepoListGitRefs(params *RepoListGitRefsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoListGitRefsOK, error)

	RepoListHooks(params *RepoListHooksParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoListHooksOK, error)

	RepoListKeys(params *RepoListKeysParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoListKeysOK, error)

	RepoListPinnedIssues(params *RepoListPinnedIssuesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoListPinnedIssuesOK, error)

	RepoListPinnedPullRequests(params *RepoListPinnedPullRequestsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoListPinnedPullRequestsOK, error)

	RepoListPullRequests(params *RepoListPullRequestsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoListPullRequestsOK, error)

	RepoListPullReviews(params *RepoListPullReviewsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoListPullReviewsOK, error)

	RepoListPushMirrors(params *RepoListPushMirrorsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoListPushMirrorsOK, error)

	RepoListReleaseAttachments(params *RepoListReleaseAttachmentsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoListReleaseAttachmentsOK, error)

	RepoListReleases(params *RepoListReleasesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoListReleasesOK, error)

	RepoListStargazers(params *RepoListStargazersParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoListStargazersOK, error)

	RepoListStatuses(params *RepoListStatusesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoListStatusesOK, error)

	RepoListStatusesByRef(params *RepoListStatusesByRefParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoListStatusesByRefOK, error)

	RepoListSubscribers(params *RepoListSubscribersParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoListSubscribersOK, error)

	RepoListTagProtection(params *RepoListTagProtectionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoListTagProtectionOK, error)

	RepoListTags(params *RepoListTagsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoListTagsOK, error)

	RepoListTeams(params *RepoListTeamsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoListTeamsOK, error)

	RepoListTopics(params *RepoListTopicsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoListTopicsOK, error)

	RepoMergePullRequest(params *RepoMergePullRequestParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoMergePullRequestOK, error)

	RepoMigrate(params *RepoMigrateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoMigrateCreated, error)

	RepoMirrorSync(params *RepoMirrorSyncParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoMirrorSyncOK, error)

	RepoNewPinAllowed(params *RepoNewPinAllowedParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoNewPinAllowedOK, error)

	RepoPullRequestIsMerged(params *RepoPullRequestIsMergedParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoPullRequestIsMergedNoContent, error)

	RepoPushMirrorSync(params *RepoPushMirrorSyncParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoPushMirrorSyncOK, error)

	RepoSearch(params *RepoSearchParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoSearchOK, error)

	RepoSigningKey(params *RepoSigningKeyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoSigningKeyOK, error)

	RepoSubmitPullReview(params *RepoSubmitPullReviewParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoSubmitPullReviewOK, error)

	RepoTestHook(params *RepoTestHookParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoTestHookNoContent, error)

	RepoTrackedTimes(params *RepoTrackedTimesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoTrackedTimesOK, error)

	RepoTransfer(params *RepoTransferParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoTransferAccepted, error)

	RepoUnDismissPullReview(params *RepoUnDismissPullReviewParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoUnDismissPullReviewOK, error)

	RepoUpdateAvatar(params *RepoUpdateAvatarParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoUpdateAvatarNoContent, error)

	RepoUpdateFile(params *RepoUpdateFileParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoUpdateFileOK, error)

	RepoUpdatePullRequest(params *RepoUpdatePullRequestParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoUpdatePullRequestOK, error)

	RepoUpdateTopics(params *RepoUpdateTopicsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoUpdateTopicsNoContent, error)

	RepoValidateIssueConfig(params *RepoValidateIssueConfigParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoValidateIssueConfigOK, error)

	TopicSearch(params *TopicSearchParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*TopicSearchOK, error)

	UpdateRepoSecret(params *UpdateRepoSecretParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateRepoSecretCreated, *UpdateRepoSecretNoContent, error)

	UpdateRepoVariable(params *UpdateRepoVariableParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateRepoVariableCreated, *UpdateRepoVariableNoContent, error)

	UserCurrentCheckSubscription(params *UserCurrentCheckSubscriptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UserCurrentCheckSubscriptionOK, error)

	UserCurrentDeleteSubscription(params *UserCurrentDeleteSubscriptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UserCurrentDeleteSubscriptionNoContent, error)

	UserCurrentPutSubscription(params *UserCurrentPutSubscriptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UserCurrentPutSubscriptionOK, error)

	UserTrackedTimes(params *UserTrackedTimesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UserTrackedTimesOK, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
GetAnnotatedTag gets the tag object of an annotated tag not lightweight tags
*/
func (a *Client) GetAnnotatedTag(params *GetAnnotatedTagParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetAnnotatedTagOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetAnnotatedTagParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetAnnotatedTag",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/git/tags/{sha}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetAnnotatedTagReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetAnnotatedTagOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetAnnotatedTag: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetBlob gets the blob of a repository
*/
func (a *Client) GetBlob(params *GetBlobParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetBlobOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetBlobParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetBlob",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/git/blobs/{sha}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetBlobReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetBlobOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetBlob: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetTree gets the tree of a repository
*/
func (a *Client) GetTree(params *GetTreeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetTreeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetTreeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetTree",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/git/trees/{sha}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetTreeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetTreeOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetTree: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ListActionTasks lists a repository s action tasks
*/
func (a *Client) ListActionTasks(params *ListActionTasksParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListActionTasksOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListActionTasksParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ListActionTasks",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/actions/tasks",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListActionTasksReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListActionTasksOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for ListActionTasks: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
AcceptRepoTransfer accepts a repo transfer
*/
func (a *Client) AcceptRepoTransfer(params *AcceptRepoTransferParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AcceptRepoTransferAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAcceptRepoTransferParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "acceptRepoTransfer",
		Method:             "POST",
		PathPattern:        "/repos/{owner}/{repo}/transfer/accept",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &AcceptRepoTransferReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AcceptRepoTransferAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for acceptRepoTransfer: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
CreateCurrentUserRepo creates a repository
*/
func (a *Client) CreateCurrentUserRepo(params *CreateCurrentUserRepoParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateCurrentUserRepoCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateCurrentUserRepoParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createCurrentUserRepo",
		Method:             "POST",
		PathPattern:        "/user/repos",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateCurrentUserRepoReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateCurrentUserRepoCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for createCurrentUserRepo: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
CreateFork forks a repository
*/
func (a *Client) CreateFork(params *CreateForkParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateForkAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateForkParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createFork",
		Method:             "POST",
		PathPattern:        "/repos/{owner}/{repo}/forks",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateForkReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateForkAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for createFork: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
CreateRepoVariable creates a repo level variable
*/
func (a *Client) CreateRepoVariable(params *CreateRepoVariableParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateRepoVariableCreated, *CreateRepoVariableNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateRepoVariableParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createRepoVariable",
		Method:             "POST",
		PathPattern:        "/repos/{owner}/{repo}/actions/variables/{variablename}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateRepoVariableReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *CreateRepoVariableCreated:
		return value, nil, nil
	case *CreateRepoVariableNoContent:
		return nil, value, nil
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repository: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DeleteRepoSecret deletes a secret in a repository
*/
func (a *Client) DeleteRepoSecret(params *DeleteRepoSecretParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteRepoSecretNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteRepoSecretParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteRepoSecret",
		Method:             "DELETE",
		PathPattern:        "/repos/{owner}/{repo}/actions/secrets/{secretname}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteRepoSecretReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteRepoSecretNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for deleteRepoSecret: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DeleteRepoVariable deletes a repo level variable
*/
func (a *Client) DeleteRepoVariable(params *DeleteRepoVariableParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteRepoVariableOK, *DeleteRepoVariableCreated, *DeleteRepoVariableNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteRepoVariableParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteRepoVariable",
		Method:             "DELETE",
		PathPattern:        "/repos/{owner}/{repo}/actions/variables/{variablename}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteRepoVariableReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, nil, err
	}
	switch value := result.(type) {
	case *DeleteRepoVariableOK:
		return value, nil, nil, nil
	case *DeleteRepoVariableCreated:
		return nil, value, nil, nil
	case *DeleteRepoVariableNoContent:
		return nil, nil, value, nil
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repository: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GenerateRepo creates a repository using a template
*/
func (a *Client) GenerateRepo(params *GenerateRepoParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GenerateRepoCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGenerateRepoParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "generateRepo",
		Method:             "POST",
		PathPattern:        "/repos/{template_owner}/{template_repo}/generate",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GenerateRepoReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GenerateRepoCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for generateRepo: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetRepoVariable gets a repo level variable
*/
func (a *Client) GetRepoVariable(params *GetRepoVariableParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRepoVariableOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRepoVariableParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getRepoVariable",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/actions/variables/{variablename}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRepoVariableReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetRepoVariableOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getRepoVariable: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetRepoVariablesList gets repo level variables list
*/
func (a *Client) GetRepoVariablesList(params *GetRepoVariablesListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRepoVariablesListOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRepoVariablesListParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getRepoVariablesList",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/actions/variables",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRepoVariablesListReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetRepoVariablesListOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getRepoVariablesList: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ListForks lists a repository s forks
*/
func (a *Client) ListForks(params *ListForksParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListForksOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListForksParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "listForks",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/forks",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListForksReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListForksOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for listForks: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RejectRepoTransfer rejects a repo transfer
*/
func (a *Client) RejectRepoTransfer(params *RejectRepoTransferParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RejectRepoTransferOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRejectRepoTransferParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "rejectRepoTransfer",
		Method:             "POST",
		PathPattern:        "/repos/{owner}/{repo}/transfer/reject",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RejectRepoTransferReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RejectRepoTransferOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for rejectRepoTransfer: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoAddCollaborator adds a collaborator to a repository
*/
func (a *Client) RepoAddCollaborator(params *RepoAddCollaboratorParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoAddCollaboratorNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoAddCollaboratorParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoAddCollaborator",
		Method:             "PUT",
		PathPattern:        "/repos/{owner}/{repo}/collaborators/{collaborator}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoAddCollaboratorReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoAddCollaboratorNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoAddCollaborator: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoAddPushMirror adds a push mirror to the repository
*/
func (a *Client) RepoAddPushMirror(params *RepoAddPushMirrorParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoAddPushMirrorOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoAddPushMirrorParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoAddPushMirror",
		Method:             "POST",
		PathPattern:        "/repos/{owner}/{repo}/push_mirrors",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoAddPushMirrorReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoAddPushMirrorOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoAddPushMirror: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoAddTeam adds a team to a repository
*/
func (a *Client) RepoAddTeam(params *RepoAddTeamParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoAddTeamNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoAddTeamParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoAddTeam",
		Method:             "PUT",
		PathPattern:        "/repos/{owner}/{repo}/teams/{team}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoAddTeamReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoAddTeamNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoAddTeam: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoAddTopic adds a topic to a repository
*/
func (a *Client) RepoAddTopic(params *RepoAddTopicParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoAddTopicNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoAddTopicParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoAddTopic",
		Method:             "PUT",
		PathPattern:        "/repos/{owner}/{repo}/topics/{topic}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoAddTopicReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoAddTopicNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoAddTopic: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoApplyDiffPatch applies diff patch to repository
*/
func (a *Client) RepoApplyDiffPatch(params *RepoApplyDiffPatchParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoApplyDiffPatchOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoApplyDiffPatchParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoApplyDiffPatch",
		Method:             "POST",
		PathPattern:        "/repos/{owner}/{repo}/diffpatch",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoApplyDiffPatchReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoApplyDiffPatchOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoApplyDiffPatch: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoCancelScheduledAutoMerge cancels the scheduled auto merge for the given pull request
*/
func (a *Client) RepoCancelScheduledAutoMerge(params *RepoCancelScheduledAutoMergeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoCancelScheduledAutoMergeNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoCancelScheduledAutoMergeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoCancelScheduledAutoMerge",
		Method:             "DELETE",
		PathPattern:        "/repos/{owner}/{repo}/pulls/{index}/merge",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoCancelScheduledAutoMergeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoCancelScheduledAutoMergeNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoCancelScheduledAutoMerge: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoChangeFiles modifies multiple files in a repository
*/
func (a *Client) RepoChangeFiles(params *RepoChangeFilesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoChangeFilesCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoChangeFilesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoChangeFiles",
		Method:             "POST",
		PathPattern:        "/repos/{owner}/{repo}/contents",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoChangeFilesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoChangeFilesCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoChangeFiles: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoCheckCollaborator checks if a user is a collaborator of a repository
*/
func (a *Client) RepoCheckCollaborator(params *RepoCheckCollaboratorParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoCheckCollaboratorNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoCheckCollaboratorParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoCheckCollaborator",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/collaborators/{collaborator}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoCheckCollaboratorReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoCheckCollaboratorNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoCheckCollaborator: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoCheckTeam checks if a team is assigned to a repository
*/
func (a *Client) RepoCheckTeam(params *RepoCheckTeamParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoCheckTeamOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoCheckTeamParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoCheckTeam",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/teams/{team}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoCheckTeamReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoCheckTeamOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoCheckTeam: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoCompareDiff gets commit comparison information
*/
func (a *Client) RepoCompareDiff(params *RepoCompareDiffParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoCompareDiffOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoCompareDiffParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoCompareDiff",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/compare/{basehead}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoCompareDiffReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoCompareDiffOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoCompareDiff: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoCreateBranch creates a branch
*/
func (a *Client) RepoCreateBranch(params *RepoCreateBranchParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoCreateBranchCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoCreateBranchParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoCreateBranch",
		Method:             "POST",
		PathPattern:        "/repos/{owner}/{repo}/branches",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoCreateBranchReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoCreateBranchCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoCreateBranch: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoCreateBranchProtection creates a branch protections for a repository
*/
func (a *Client) RepoCreateBranchProtection(params *RepoCreateBranchProtectionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoCreateBranchProtectionCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoCreateBranchProtectionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoCreateBranchProtection",
		Method:             "POST",
		PathPattern:        "/repos/{owner}/{repo}/branch_protections",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoCreateBranchProtectionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoCreateBranchProtectionCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoCreateBranchProtection: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoCreateFile creates a file in a repository
*/
func (a *Client) RepoCreateFile(params *RepoCreateFileParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoCreateFileCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoCreateFileParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoCreateFile",
		Method:             "POST",
		PathPattern:        "/repos/{owner}/{repo}/contents/{filepath}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoCreateFileReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoCreateFileCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoCreateFile: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoCreateHook creates a hook
*/
func (a *Client) RepoCreateHook(params *RepoCreateHookParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoCreateHookCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoCreateHookParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoCreateHook",
		Method:             "POST",
		PathPattern:        "/repos/{owner}/{repo}/hooks",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoCreateHookReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoCreateHookCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoCreateHook: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoCreateKey adds a key to a repository
*/
func (a *Client) RepoCreateKey(params *RepoCreateKeyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoCreateKeyCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoCreateKeyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoCreateKey",
		Method:             "POST",
		PathPattern:        "/repos/{owner}/{repo}/keys",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoCreateKeyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoCreateKeyCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoCreateKey: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoCreatePullRequest creates a pull request
*/
func (a *Client) RepoCreatePullRequest(params *RepoCreatePullRequestParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoCreatePullRequestCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoCreatePullRequestParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoCreatePullRequest",
		Method:             "POST",
		PathPattern:        "/repos/{owner}/{repo}/pulls",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoCreatePullRequestReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoCreatePullRequestCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoCreatePullRequest: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoCreatePullReview creates a review to an pull request
*/
func (a *Client) RepoCreatePullReview(params *RepoCreatePullReviewParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoCreatePullReviewOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoCreatePullReviewParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoCreatePullReview",
		Method:             "POST",
		PathPattern:        "/repos/{owner}/{repo}/pulls/{index}/reviews",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoCreatePullReviewReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoCreatePullReviewOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoCreatePullReview: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoCreatePullReviewRequests creates review requests for a pull request
*/
func (a *Client) RepoCreatePullReviewRequests(params *RepoCreatePullReviewRequestsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoCreatePullReviewRequestsCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoCreatePullReviewRequestsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoCreatePullReviewRequests",
		Method:             "POST",
		PathPattern:        "/repos/{owner}/{repo}/pulls/{index}/requested_reviewers",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoCreatePullReviewRequestsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoCreatePullReviewRequestsCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoCreatePullReviewRequests: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoCreateRelease creates a release
*/
func (a *Client) RepoCreateRelease(params *RepoCreateReleaseParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoCreateReleaseCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoCreateReleaseParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoCreateRelease",
		Method:             "POST",
		PathPattern:        "/repos/{owner}/{repo}/releases",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoCreateReleaseReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoCreateReleaseCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoCreateRelease: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoCreateReleaseAttachment creates a release attachment
*/
func (a *Client) RepoCreateReleaseAttachment(params *RepoCreateReleaseAttachmentParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoCreateReleaseAttachmentCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoCreateReleaseAttachmentParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoCreateReleaseAttachment",
		Method:             "POST",
		PathPattern:        "/repos/{owner}/{repo}/releases/{id}/assets",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"multipart/form-data", "application/octet-stream"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoCreateReleaseAttachmentReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoCreateReleaseAttachmentCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoCreateReleaseAttachment: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoCreateStatus creates a commit status
*/
func (a *Client) RepoCreateStatus(params *RepoCreateStatusParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoCreateStatusCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoCreateStatusParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoCreateStatus",
		Method:             "POST",
		PathPattern:        "/repos/{owner}/{repo}/statuses/{sha}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoCreateStatusReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoCreateStatusCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoCreateStatus: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoCreateTag creates a new git tag in a repository
*/
func (a *Client) RepoCreateTag(params *RepoCreateTagParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoCreateTagOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoCreateTagParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoCreateTag",
		Method:             "POST",
		PathPattern:        "/repos/{owner}/{repo}/tags",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoCreateTagReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoCreateTagOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoCreateTag: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoCreateTagProtection creates a tag protections for a repository
*/
func (a *Client) RepoCreateTagProtection(params *RepoCreateTagProtectionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoCreateTagProtectionCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoCreateTagProtectionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoCreateTagProtection",
		Method:             "POST",
		PathPattern:        "/repos/{owner}/{repo}/tag_protections",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoCreateTagProtectionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoCreateTagProtectionCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoCreateTagProtection: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoCreateWikiPage creates a wiki page
*/
func (a *Client) RepoCreateWikiPage(params *RepoCreateWikiPageParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoCreateWikiPageCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoCreateWikiPageParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoCreateWikiPage",
		Method:             "POST",
		PathPattern:        "/repos/{owner}/{repo}/wiki/new",
		ProducesMediaTypes: []string{"application/json", "text/html"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoCreateWikiPageReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoCreateWikiPageCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoCreateWikiPage: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoDelete deletes a repository
*/
func (a *Client) RepoDelete(params *RepoDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoDeleteNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoDelete",
		Method:             "DELETE",
		PathPattern:        "/repos/{owner}/{repo}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoDeleteNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoDelete: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoDeleteAvatar deletes avatar
*/
func (a *Client) RepoDeleteAvatar(params *RepoDeleteAvatarParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoDeleteAvatarNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoDeleteAvatarParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoDeleteAvatar",
		Method:             "DELETE",
		PathPattern:        "/repos/{owner}/{repo}/avatar",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoDeleteAvatarReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoDeleteAvatarNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoDeleteAvatar: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoDeleteBranch deletes a specific branch from a repository
*/
func (a *Client) RepoDeleteBranch(params *RepoDeleteBranchParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoDeleteBranchNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoDeleteBranchParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoDeleteBranch",
		Method:             "DELETE",
		PathPattern:        "/repos/{owner}/{repo}/branches/{branch}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoDeleteBranchReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoDeleteBranchNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoDeleteBranch: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoDeleteBranchProtection deletes a specific branch protection for the repository
*/
func (a *Client) RepoDeleteBranchProtection(params *RepoDeleteBranchProtectionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoDeleteBranchProtectionNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoDeleteBranchProtectionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoDeleteBranchProtection",
		Method:             "DELETE",
		PathPattern:        "/repos/{owner}/{repo}/branch_protections/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoDeleteBranchProtectionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoDeleteBranchProtectionNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoDeleteBranchProtection: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoDeleteCollaborator deletes a collaborator from a repository
*/
func (a *Client) RepoDeleteCollaborator(params *RepoDeleteCollaboratorParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoDeleteCollaboratorNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoDeleteCollaboratorParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoDeleteCollaborator",
		Method:             "DELETE",
		PathPattern:        "/repos/{owner}/{repo}/collaborators/{collaborator}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoDeleteCollaboratorReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoDeleteCollaboratorNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoDeleteCollaborator: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoDeleteFile deletes a file in a repository
*/
func (a *Client) RepoDeleteFile(params *RepoDeleteFileParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoDeleteFileOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoDeleteFileParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoDeleteFile",
		Method:             "DELETE",
		PathPattern:        "/repos/{owner}/{repo}/contents/{filepath}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoDeleteFileReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoDeleteFileOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoDeleteFile: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoDeleteGitHook deletes a git hook in a repository
*/
func (a *Client) RepoDeleteGitHook(params *RepoDeleteGitHookParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoDeleteGitHookNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoDeleteGitHookParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoDeleteGitHook",
		Method:             "DELETE",
		PathPattern:        "/repos/{owner}/{repo}/hooks/git/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoDeleteGitHookReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoDeleteGitHookNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoDeleteGitHook: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoDeleteHook deletes a hook in a repository
*/
func (a *Client) RepoDeleteHook(params *RepoDeleteHookParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoDeleteHookNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoDeleteHookParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoDeleteHook",
		Method:             "DELETE",
		PathPattern:        "/repos/{owner}/{repo}/hooks/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoDeleteHookReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoDeleteHookNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoDeleteHook: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoDeleteKey deletes a key from a repository
*/
func (a *Client) RepoDeleteKey(params *RepoDeleteKeyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoDeleteKeyNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoDeleteKeyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoDeleteKey",
		Method:             "DELETE",
		PathPattern:        "/repos/{owner}/{repo}/keys/{id}",
		ProducesMediaTypes: []string{"application/json", "text/html"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoDeleteKeyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoDeleteKeyNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoDeleteKey: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoDeletePullReview deletes a specific review from a pull request
*/
func (a *Client) RepoDeletePullReview(params *RepoDeletePullReviewParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoDeletePullReviewNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoDeletePullReviewParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoDeletePullReview",
		Method:             "DELETE",
		PathPattern:        "/repos/{owner}/{repo}/pulls/{index}/reviews/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoDeletePullReviewReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoDeletePullReviewNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoDeletePullReview: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoDeletePullReviewRequests cancels review requests for a pull request
*/
func (a *Client) RepoDeletePullReviewRequests(params *RepoDeletePullReviewRequestsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoDeletePullReviewRequestsNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoDeletePullReviewRequestsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoDeletePullReviewRequests",
		Method:             "DELETE",
		PathPattern:        "/repos/{owner}/{repo}/pulls/{index}/requested_reviewers",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoDeletePullReviewRequestsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoDeletePullReviewRequestsNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoDeletePullReviewRequests: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoDeletePushMirror deletes a push mirror from a repository by remote name
*/
func (a *Client) RepoDeletePushMirror(params *RepoDeletePushMirrorParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoDeletePushMirrorNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoDeletePushMirrorParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoDeletePushMirror",
		Method:             "DELETE",
		PathPattern:        "/repos/{owner}/{repo}/push_mirrors/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoDeletePushMirrorReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoDeletePushMirrorNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoDeletePushMirror: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoDeleteRelease deletes a release
*/
func (a *Client) RepoDeleteRelease(params *RepoDeleteReleaseParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoDeleteReleaseNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoDeleteReleaseParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoDeleteRelease",
		Method:             "DELETE",
		PathPattern:        "/repos/{owner}/{repo}/releases/{id}",
		ProducesMediaTypes: []string{"application/json", "text/html"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoDeleteReleaseReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoDeleteReleaseNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoDeleteRelease: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoDeleteReleaseAttachment deletes a release attachment
*/
func (a *Client) RepoDeleteReleaseAttachment(params *RepoDeleteReleaseAttachmentParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoDeleteReleaseAttachmentNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoDeleteReleaseAttachmentParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoDeleteReleaseAttachment",
		Method:             "DELETE",
		PathPattern:        "/repos/{owner}/{repo}/releases/{id}/assets/{attachment_id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoDeleteReleaseAttachmentReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoDeleteReleaseAttachmentNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoDeleteReleaseAttachment: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoDeleteReleaseByTag deletes a release by tag name
*/
func (a *Client) RepoDeleteReleaseByTag(params *RepoDeleteReleaseByTagParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoDeleteReleaseByTagNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoDeleteReleaseByTagParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoDeleteReleaseByTag",
		Method:             "DELETE",
		PathPattern:        "/repos/{owner}/{repo}/releases/tags/{tag}",
		ProducesMediaTypes: []string{"application/json", "text/html"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoDeleteReleaseByTagReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoDeleteReleaseByTagNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoDeleteReleaseByTag: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoDeleteTag deletes a repository s tag by name
*/
func (a *Client) RepoDeleteTag(params *RepoDeleteTagParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoDeleteTagNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoDeleteTagParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoDeleteTag",
		Method:             "DELETE",
		PathPattern:        "/repos/{owner}/{repo}/tags/{tag}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoDeleteTagReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoDeleteTagNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoDeleteTag: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoDeleteTagProtection deletes a specific tag protection for the repository
*/
func (a *Client) RepoDeleteTagProtection(params *RepoDeleteTagProtectionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoDeleteTagProtectionNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoDeleteTagProtectionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoDeleteTagProtection",
		Method:             "DELETE",
		PathPattern:        "/repos/{owner}/{repo}/tag_protections/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoDeleteTagProtectionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoDeleteTagProtectionNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoDeleteTagProtection: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoDeleteTeam deletes a team from a repository
*/
func (a *Client) RepoDeleteTeam(params *RepoDeleteTeamParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoDeleteTeamNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoDeleteTeamParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoDeleteTeam",
		Method:             "DELETE",
		PathPattern:        "/repos/{owner}/{repo}/teams/{team}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoDeleteTeamReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoDeleteTeamNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoDeleteTeam: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoDeleteTopic deletes a topic from a repository
*/
func (a *Client) RepoDeleteTopic(params *RepoDeleteTopicParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoDeleteTopicNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoDeleteTopicParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoDeleteTopic",
		Method:             "DELETE",
		PathPattern:        "/repos/{owner}/{repo}/topics/{topic}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoDeleteTopicReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoDeleteTopicNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoDeleteTopic: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoDeleteWikiPage deletes a wiki page
*/
func (a *Client) RepoDeleteWikiPage(params *RepoDeleteWikiPageParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoDeleteWikiPageNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoDeleteWikiPageParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoDeleteWikiPage",
		Method:             "DELETE",
		PathPattern:        "/repos/{owner}/{repo}/wiki/page/{pageName}",
		ProducesMediaTypes: []string{"application/json", "text/html"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoDeleteWikiPageReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoDeleteWikiPageNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoDeleteWikiPage: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoDismissPullReview dismisses a review for a pull request
*/
func (a *Client) RepoDismissPullReview(params *RepoDismissPullReviewParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoDismissPullReviewOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoDismissPullReviewParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoDismissPullReview",
		Method:             "POST",
		PathPattern:        "/repos/{owner}/{repo}/pulls/{index}/reviews/{id}/dismissals",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoDismissPullReviewReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoDismissPullReviewOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoDismissPullReview: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoDownloadCommitDiffOrPatch gets a commit s diff or patch
*/
func (a *Client) RepoDownloadCommitDiffOrPatch(params *RepoDownloadCommitDiffOrPatchParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoDownloadCommitDiffOrPatchOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoDownloadCommitDiffOrPatchParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoDownloadCommitDiffOrPatch",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/git/commits/{sha}.{diffType}",
		ProducesMediaTypes: []string{"text/plain"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoDownloadCommitDiffOrPatchReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoDownloadCommitDiffOrPatchOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoDownloadCommitDiffOrPatch: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoDownloadPullDiffOrPatch gets a pull request diff or patch
*/
func (a *Client) RepoDownloadPullDiffOrPatch(params *RepoDownloadPullDiffOrPatchParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoDownloadPullDiffOrPatchOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoDownloadPullDiffOrPatchParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoDownloadPullDiffOrPatch",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/pulls/{index}.{diffType}",
		ProducesMediaTypes: []string{"text/plain"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoDownloadPullDiffOrPatchReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoDownloadPullDiffOrPatchOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoDownloadPullDiffOrPatch: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoEdit edits a repository s properties only fields that are set will be changed
*/
func (a *Client) RepoEdit(params *RepoEditParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoEditOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoEditParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoEdit",
		Method:             "PATCH",
		PathPattern:        "/repos/{owner}/{repo}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoEditReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoEditOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoEdit: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoEditBranchProtection edits a branch protections for a repository only fields that are set will be changed
*/
func (a *Client) RepoEditBranchProtection(params *RepoEditBranchProtectionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoEditBranchProtectionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoEditBranchProtectionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoEditBranchProtection",
		Method:             "PATCH",
		PathPattern:        "/repos/{owner}/{repo}/branch_protections/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoEditBranchProtectionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoEditBranchProtectionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoEditBranchProtection: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoEditGitHook edits a git hook in a repository
*/
func (a *Client) RepoEditGitHook(params *RepoEditGitHookParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoEditGitHookOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoEditGitHookParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoEditGitHook",
		Method:             "PATCH",
		PathPattern:        "/repos/{owner}/{repo}/hooks/git/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoEditGitHookReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoEditGitHookOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoEditGitHook: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoEditHook edits a hook in a repository
*/
func (a *Client) RepoEditHook(params *RepoEditHookParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoEditHookOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoEditHookParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoEditHook",
		Method:             "PATCH",
		PathPattern:        "/repos/{owner}/{repo}/hooks/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoEditHookReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoEditHookOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoEditHook: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoEditPullRequest updates a pull request if using deadline only the date will be taken into account and time of day ignored
*/
func (a *Client) RepoEditPullRequest(params *RepoEditPullRequestParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoEditPullRequestCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoEditPullRequestParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoEditPullRequest",
		Method:             "PATCH",
		PathPattern:        "/repos/{owner}/{repo}/pulls/{index}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoEditPullRequestReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoEditPullRequestCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoEditPullRequest: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoEditRelease updates a release
*/
func (a *Client) RepoEditRelease(params *RepoEditReleaseParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoEditReleaseOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoEditReleaseParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoEditRelease",
		Method:             "PATCH",
		PathPattern:        "/repos/{owner}/{repo}/releases/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoEditReleaseReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoEditReleaseOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoEditRelease: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoEditReleaseAttachment edits a release attachment
*/
func (a *Client) RepoEditReleaseAttachment(params *RepoEditReleaseAttachmentParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoEditReleaseAttachmentCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoEditReleaseAttachmentParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoEditReleaseAttachment",
		Method:             "PATCH",
		PathPattern:        "/repos/{owner}/{repo}/releases/{id}/assets/{attachment_id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoEditReleaseAttachmentReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoEditReleaseAttachmentCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoEditReleaseAttachment: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoEditTagProtection edits a tag protections for a repository only fields that are set will be changed
*/
func (a *Client) RepoEditTagProtection(params *RepoEditTagProtectionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoEditTagProtectionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoEditTagProtectionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoEditTagProtection",
		Method:             "PATCH",
		PathPattern:        "/repos/{owner}/{repo}/tag_protections/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoEditTagProtectionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoEditTagProtectionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoEditTagProtection: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoEditWikiPage edits a wiki page
*/
func (a *Client) RepoEditWikiPage(params *RepoEditWikiPageParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoEditWikiPageOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoEditWikiPageParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoEditWikiPage",
		Method:             "PATCH",
		PathPattern:        "/repos/{owner}/{repo}/wiki/page/{pageName}",
		ProducesMediaTypes: []string{"application/json", "text/html"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoEditWikiPageReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoEditWikiPageOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoEditWikiPage: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoGet gets a repository
*/
func (a *Client) RepoGet(params *RepoGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoGet",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoGet: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoGetAllCommits gets a list of all commits from a repository
*/
func (a *Client) RepoGetAllCommits(params *RepoGetAllCommitsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetAllCommitsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoGetAllCommitsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoGetAllCommits",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/commits",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoGetAllCommitsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoGetAllCommitsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoGetAllCommits: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoGetArchive gets an archive of a repository
*/
func (a *Client) RepoGetArchive(params *RepoGetArchiveParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetArchiveOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoGetArchiveParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoGetArchive",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/archive/{archive}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoGetArchiveReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoGetArchiveOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoGetArchive: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoGetAssignees returns all users that have write access and can be assigned to issues
*/
func (a *Client) RepoGetAssignees(params *RepoGetAssigneesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetAssigneesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoGetAssigneesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoGetAssignees",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/assignees",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoGetAssigneesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoGetAssigneesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoGetAssignees: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoGetBranch retrieves a specific branch from a repository including its effective branch protection
*/
func (a *Client) RepoGetBranch(params *RepoGetBranchParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetBranchOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoGetBranchParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoGetBranch",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/branches/{branch}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoGetBranchReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoGetBranchOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoGetBranch: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoGetBranchProtection gets a specific branch protection for the repository
*/
func (a *Client) RepoGetBranchProtection(params *RepoGetBranchProtectionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetBranchProtectionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoGetBranchProtectionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoGetBranchProtection",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/branch_protections/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoGetBranchProtectionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoGetBranchProtectionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoGetBranchProtection: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoGetByID gets a repository by id
*/
func (a *Client) RepoGetByID(params *RepoGetByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetByIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoGetByIDParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoGetByID",
		Method:             "GET",
		PathPattern:        "/repositories/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoGetByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoGetByIDOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoGetByID: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoGetCombinedStatusByRef gets a commit s combined status by branch tag commit reference
*/
func (a *Client) RepoGetCombinedStatusByRef(params *RepoGetCombinedStatusByRefParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetCombinedStatusByRefOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoGetCombinedStatusByRefParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoGetCombinedStatusByRef",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/commits/{ref}/status",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoGetCombinedStatusByRefReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoGetCombinedStatusByRefOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoGetCombinedStatusByRef: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoGetCommitPullRequest gets the pull request of the commit
*/
func (a *Client) RepoGetCommitPullRequest(params *RepoGetCommitPullRequestParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetCommitPullRequestOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoGetCommitPullRequestParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoGetCommitPullRequest",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/commits/{sha}/pull",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoGetCommitPullRequestReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoGetCommitPullRequestOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoGetCommitPullRequest: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoGetContents gets the metadata and contents if a file of an entry in a repository or a list of entries if a dir
*/
func (a *Client) RepoGetContents(params *RepoGetContentsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetContentsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoGetContentsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoGetContents",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/contents/{filepath}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoGetContentsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoGetContentsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoGetContents: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoGetContentsList gets the metadata of all the entries of the root dir
*/
func (a *Client) RepoGetContentsList(params *RepoGetContentsListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetContentsListOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoGetContentsListParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoGetContentsList",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/contents",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoGetContentsListReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoGetContentsListOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoGetContentsList: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoGetEditorConfig gets the editor config definitions of a file in a repository
*/
func (a *Client) RepoGetEditorConfig(params *RepoGetEditorConfigParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetEditorConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoGetEditorConfigParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoGetEditorConfig",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/editorconfig/{filepath}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoGetEditorConfigReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoGetEditorConfigOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoGetEditorConfig: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoGetGitHook gets a git hook
*/
func (a *Client) RepoGetGitHook(params *RepoGetGitHookParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetGitHookOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoGetGitHookParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoGetGitHook",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/hooks/git/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoGetGitHookReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoGetGitHookOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoGetGitHook: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoGetHook gets a hook
*/
func (a *Client) RepoGetHook(params *RepoGetHookParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetHookOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoGetHookParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoGetHook",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/hooks/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoGetHookReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoGetHookOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoGetHook: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoGetIssueConfig returns the issue config for a repo
*/
func (a *Client) RepoGetIssueConfig(params *RepoGetIssueConfigParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetIssueConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoGetIssueConfigParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoGetIssueConfig",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/issue_config",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoGetIssueConfigReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoGetIssueConfigOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoGetIssueConfig: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoGetIssueTemplates gets available issue templates for a repository
*/
func (a *Client) RepoGetIssueTemplates(params *RepoGetIssueTemplatesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetIssueTemplatesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoGetIssueTemplatesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoGetIssueTemplates",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/issue_templates",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoGetIssueTemplatesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoGetIssueTemplatesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoGetIssueTemplates: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoGetKey gets a repository s key by id
*/
func (a *Client) RepoGetKey(params *RepoGetKeyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetKeyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoGetKeyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoGetKey",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/keys/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoGetKeyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoGetKeyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoGetKey: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoGetLanguages gets languages and number of bytes of code written
*/
func (a *Client) RepoGetLanguages(params *RepoGetLanguagesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetLanguagesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoGetLanguagesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoGetLanguages",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/languages",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoGetLanguagesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoGetLanguagesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoGetLanguages: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoGetLatestRelease gets the most recent non prerelease non draft release of a repository sorted by created at
*/
func (a *Client) RepoGetLatestRelease(params *RepoGetLatestReleaseParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetLatestReleaseOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoGetLatestReleaseParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoGetLatestRelease",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/releases/latest",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoGetLatestReleaseReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoGetLatestReleaseOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoGetLatestRelease: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoGetNote gets a note corresponding to a single commit from a repository
*/
func (a *Client) RepoGetNote(params *RepoGetNoteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetNoteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoGetNoteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoGetNote",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/git/notes/{sha}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoGetNoteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoGetNoteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoGetNote: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoGetPullRequest gets a pull request
*/
func (a *Client) RepoGetPullRequest(params *RepoGetPullRequestParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetPullRequestOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoGetPullRequestParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoGetPullRequest",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/pulls/{index}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoGetPullRequestReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoGetPullRequestOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoGetPullRequest: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoGetPullRequestByBaseHead gets a pull request by base and head
*/
func (a *Client) RepoGetPullRequestByBaseHead(params *RepoGetPullRequestByBaseHeadParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetPullRequestByBaseHeadOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoGetPullRequestByBaseHeadParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoGetPullRequestByBaseHead",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/pulls/{base}/{head}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoGetPullRequestByBaseHeadReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoGetPullRequestByBaseHeadOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoGetPullRequestByBaseHead: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoGetPullRequestCommits gets commits for a pull request
*/
func (a *Client) RepoGetPullRequestCommits(params *RepoGetPullRequestCommitsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetPullRequestCommitsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoGetPullRequestCommitsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoGetPullRequestCommits",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/pulls/{index}/commits",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoGetPullRequestCommitsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoGetPullRequestCommitsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoGetPullRequestCommits: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoGetPullRequestFiles gets changed files for a pull request
*/
func (a *Client) RepoGetPullRequestFiles(params *RepoGetPullRequestFilesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetPullRequestFilesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoGetPullRequestFilesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoGetPullRequestFiles",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/pulls/{index}/files",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoGetPullRequestFilesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoGetPullRequestFilesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoGetPullRequestFiles: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoGetPullReview gets a specific review for a pull request
*/
func (a *Client) RepoGetPullReview(params *RepoGetPullReviewParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetPullReviewOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoGetPullReviewParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoGetPullReview",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/pulls/{index}/reviews/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoGetPullReviewReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoGetPullReviewOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoGetPullReview: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoGetPullReviewComments gets a specific review for a pull request
*/
func (a *Client) RepoGetPullReviewComments(params *RepoGetPullReviewCommentsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetPullReviewCommentsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoGetPullReviewCommentsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoGetPullReviewComments",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/pulls/{index}/reviews/{id}/comments",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoGetPullReviewCommentsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoGetPullReviewCommentsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoGetPullReviewComments: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoGetPushMirrorByRemoteName gets push mirror of the repository by remote name
*/
func (a *Client) RepoGetPushMirrorByRemoteName(params *RepoGetPushMirrorByRemoteNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetPushMirrorByRemoteNameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoGetPushMirrorByRemoteNameParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoGetPushMirrorByRemoteName",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/push_mirrors/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoGetPushMirrorByRemoteNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoGetPushMirrorByRemoteNameOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoGetPushMirrorByRemoteName: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoGetRawFile gets a file from a repository
*/
func (a *Client) RepoGetRawFile(params *RepoGetRawFileParams, authInfo runtime.ClientAuthInfoWriter, writer io.Writer, opts ...ClientOption) (*RepoGetRawFileOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoGetRawFileParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoGetRawFile",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/raw/{filepath}",
		ProducesMediaTypes: []string{"application/octet-stream"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoGetRawFileReader{formats: a.formats, writer: writer},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoGetRawFileOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoGetRawFile: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoGetRawFileOrLFS gets a file or it s l f s object from a repository
*/
func (a *Client) RepoGetRawFileOrLFS(params *RepoGetRawFileOrLFSParams, authInfo runtime.ClientAuthInfoWriter, writer io.Writer, opts ...ClientOption) (*RepoGetRawFileOrLFSOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoGetRawFileOrLFSParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoGetRawFileOrLFS",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/media/{filepath}",
		ProducesMediaTypes: []string{"application/octet-stream"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoGetRawFileOrLFSReader{formats: a.formats, writer: writer},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoGetRawFileOrLFSOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoGetRawFileOrLFS: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoGetRelease gets a release
*/
func (a *Client) RepoGetRelease(params *RepoGetReleaseParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetReleaseOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoGetReleaseParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoGetRelease",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/releases/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoGetReleaseReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoGetReleaseOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoGetRelease: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoGetReleaseAttachment gets a release attachment
*/
func (a *Client) RepoGetReleaseAttachment(params *RepoGetReleaseAttachmentParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetReleaseAttachmentOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoGetReleaseAttachmentParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoGetReleaseAttachment",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/releases/{id}/assets/{attachment_id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoGetReleaseAttachmentReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoGetReleaseAttachmentOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoGetReleaseAttachment: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoGetReleaseByTag gets a release by tag name
*/
func (a *Client) RepoGetReleaseByTag(params *RepoGetReleaseByTagParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetReleaseByTagOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoGetReleaseByTagParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoGetReleaseByTag",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/releases/tags/{tag}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoGetReleaseByTagReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoGetReleaseByTagOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoGetReleaseByTag: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoGetRepoPermissions gets repository permissions for a user
*/
func (a *Client) RepoGetRepoPermissions(params *RepoGetRepoPermissionsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetRepoPermissionsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoGetRepoPermissionsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoGetRepoPermissions",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/collaborators/{collaborator}/permission",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoGetRepoPermissionsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoGetRepoPermissionsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoGetRepoPermissions: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoGetReviewers returns all users that can be requested to review in this repo
*/
func (a *Client) RepoGetReviewers(params *RepoGetReviewersParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetReviewersOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoGetReviewersParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoGetReviewers",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/reviewers",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoGetReviewersReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoGetReviewersOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoGetReviewers: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoGetRunnerRegistrationToken gets a repository s actions runner registration token
*/
func (a *Client) RepoGetRunnerRegistrationToken(params *RepoGetRunnerRegistrationTokenParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetRunnerRegistrationTokenOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoGetRunnerRegistrationTokenParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoGetRunnerRegistrationToken",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/runners/registration-token",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoGetRunnerRegistrationTokenReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoGetRunnerRegistrationTokenOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoGetRunnerRegistrationToken: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoGetSingleCommit gets a single commit from a repository
*/
func (a *Client) RepoGetSingleCommit(params *RepoGetSingleCommitParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetSingleCommitOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoGetSingleCommitParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoGetSingleCommit",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/git/commits/{sha}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoGetSingleCommitReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoGetSingleCommitOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoGetSingleCommit: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoGetTag gets the tag of a repository by tag name
*/
func (a *Client) RepoGetTag(params *RepoGetTagParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetTagOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoGetTagParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoGetTag",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/tags/{tag}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoGetTagReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoGetTagOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoGetTag: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoGetTagProtection gets a specific tag protection for the repository
*/
func (a *Client) RepoGetTagProtection(params *RepoGetTagProtectionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetTagProtectionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoGetTagProtectionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoGetTagProtection",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/tag_protections/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoGetTagProtectionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoGetTagProtectionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoGetTagProtection: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoGetWikiPage gets a wiki page
*/
func (a *Client) RepoGetWikiPage(params *RepoGetWikiPageParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetWikiPageOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoGetWikiPageParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoGetWikiPage",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/wiki/page/{pageName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoGetWikiPageReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoGetWikiPageOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoGetWikiPage: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoGetWikiPageRevisions gets revisions of a wiki page
*/
func (a *Client) RepoGetWikiPageRevisions(params *RepoGetWikiPageRevisionsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetWikiPageRevisionsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoGetWikiPageRevisionsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoGetWikiPageRevisions",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/wiki/revisions/{pageName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoGetWikiPageRevisionsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoGetWikiPageRevisionsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoGetWikiPageRevisions: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoGetWikiPages gets all wiki pages
*/
func (a *Client) RepoGetWikiPages(params *RepoGetWikiPagesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoGetWikiPagesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoGetWikiPagesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoGetWikiPages",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/wiki/pages",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoGetWikiPagesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoGetWikiPagesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoGetWikiPages: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoListActionsSecrets lists an repo s actions secrets
*/
func (a *Client) RepoListActionsSecrets(params *RepoListActionsSecretsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoListActionsSecretsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoListActionsSecretsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoListActionsSecrets",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/actions/secrets",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoListActionsSecretsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoListActionsSecretsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoListActionsSecrets: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoListActivityFeeds lists a repository s activity feeds
*/
func (a *Client) RepoListActivityFeeds(params *RepoListActivityFeedsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoListActivityFeedsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoListActivityFeedsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoListActivityFeeds",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/activities/feeds",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoListActivityFeedsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoListActivityFeedsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoListActivityFeeds: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoListAllGitRefs gets specified ref or filtered repository s refs
*/
func (a *Client) RepoListAllGitRefs(params *RepoListAllGitRefsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoListAllGitRefsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoListAllGitRefsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoListAllGitRefs",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/git/refs",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoListAllGitRefsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoListAllGitRefsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoListAllGitRefs: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoListBranchProtection lists branch protections for a repository
*/
func (a *Client) RepoListBranchProtection(params *RepoListBranchProtectionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoListBranchProtectionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoListBranchProtectionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoListBranchProtection",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/branch_protections",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoListBranchProtectionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoListBranchProtectionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoListBranchProtection: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoListBranches lists a repository s branches
*/
func (a *Client) RepoListBranches(params *RepoListBranchesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoListBranchesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoListBranchesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoListBranches",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/branches",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoListBranchesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoListBranchesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoListBranches: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoListCollaborators lists a repository s collaborators
*/
func (a *Client) RepoListCollaborators(params *RepoListCollaboratorsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoListCollaboratorsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoListCollaboratorsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoListCollaborators",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/collaborators",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoListCollaboratorsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoListCollaboratorsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoListCollaborators: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoListGitHooks lists the git hooks in a repository
*/
func (a *Client) RepoListGitHooks(params *RepoListGitHooksParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoListGitHooksOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoListGitHooksParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoListGitHooks",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/hooks/git",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoListGitHooksReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoListGitHooksOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoListGitHooks: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoListGitRefs gets specified ref or filtered repository s refs
*/
func (a *Client) RepoListGitRefs(params *RepoListGitRefsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoListGitRefsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoListGitRefsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoListGitRefs",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/git/refs/{ref}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoListGitRefsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoListGitRefsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoListGitRefs: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoListHooks lists the hooks in a repository
*/
func (a *Client) RepoListHooks(params *RepoListHooksParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoListHooksOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoListHooksParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoListHooks",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/hooks",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoListHooksReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoListHooksOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoListHooks: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoListKeys lists a repository s keys
*/
func (a *Client) RepoListKeys(params *RepoListKeysParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoListKeysOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoListKeysParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoListKeys",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/keys",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoListKeysReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoListKeysOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoListKeys: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoListPinnedIssues lists a repo s pinned issues
*/
func (a *Client) RepoListPinnedIssues(params *RepoListPinnedIssuesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoListPinnedIssuesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoListPinnedIssuesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoListPinnedIssues",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/issues/pinned",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoListPinnedIssuesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoListPinnedIssuesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoListPinnedIssues: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoListPinnedPullRequests lists a repo s pinned pull requests
*/
func (a *Client) RepoListPinnedPullRequests(params *RepoListPinnedPullRequestsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoListPinnedPullRequestsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoListPinnedPullRequestsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoListPinnedPullRequests",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/pulls/pinned",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoListPinnedPullRequestsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoListPinnedPullRequestsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoListPinnedPullRequests: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoListPullRequests lists a repo s pull requests
*/
func (a *Client) RepoListPullRequests(params *RepoListPullRequestsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoListPullRequestsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoListPullRequestsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoListPullRequests",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/pulls",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoListPullRequestsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoListPullRequestsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoListPullRequests: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoListPullReviews lists all reviews for a pull request
*/
func (a *Client) RepoListPullReviews(params *RepoListPullReviewsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoListPullReviewsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoListPullReviewsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoListPullReviews",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/pulls/{index}/reviews",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoListPullReviewsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoListPullReviewsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoListPullReviews: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoListPushMirrors gets all push mirrors of the repository
*/
func (a *Client) RepoListPushMirrors(params *RepoListPushMirrorsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoListPushMirrorsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoListPushMirrorsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoListPushMirrors",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/push_mirrors",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoListPushMirrorsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoListPushMirrorsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoListPushMirrors: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoListReleaseAttachments lists release s attachments
*/
func (a *Client) RepoListReleaseAttachments(params *RepoListReleaseAttachmentsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoListReleaseAttachmentsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoListReleaseAttachmentsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoListReleaseAttachments",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/releases/{id}/assets",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoListReleaseAttachmentsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoListReleaseAttachmentsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoListReleaseAttachments: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoListReleases lists a repo s releases
*/
func (a *Client) RepoListReleases(params *RepoListReleasesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoListReleasesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoListReleasesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoListReleases",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/releases",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoListReleasesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoListReleasesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoListReleases: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoListStargazers lists a repo s stargazers
*/
func (a *Client) RepoListStargazers(params *RepoListStargazersParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoListStargazersOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoListStargazersParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoListStargazers",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/stargazers",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoListStargazersReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoListStargazersOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoListStargazers: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoListStatuses gets a commit s statuses
*/
func (a *Client) RepoListStatuses(params *RepoListStatusesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoListStatusesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoListStatusesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoListStatuses",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/statuses/{sha}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoListStatusesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoListStatusesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoListStatuses: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoListStatusesByRef gets a commit s statuses by branch tag commit reference
*/
func (a *Client) RepoListStatusesByRef(params *RepoListStatusesByRefParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoListStatusesByRefOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoListStatusesByRefParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoListStatusesByRef",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/commits/{ref}/statuses",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoListStatusesByRefReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoListStatusesByRefOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoListStatusesByRef: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoListSubscribers lists a repo s watchers
*/
func (a *Client) RepoListSubscribers(params *RepoListSubscribersParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoListSubscribersOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoListSubscribersParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoListSubscribers",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/subscribers",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoListSubscribersReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoListSubscribersOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoListSubscribers: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoListTagProtection lists tag protections for a repository
*/
func (a *Client) RepoListTagProtection(params *RepoListTagProtectionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoListTagProtectionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoListTagProtectionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoListTagProtection",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/tag_protections",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoListTagProtectionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoListTagProtectionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoListTagProtection: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoListTags lists a repository s tags
*/
func (a *Client) RepoListTags(params *RepoListTagsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoListTagsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoListTagsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoListTags",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/tags",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoListTagsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoListTagsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoListTags: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoListTeams lists a repository s teams
*/
func (a *Client) RepoListTeams(params *RepoListTeamsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoListTeamsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoListTeamsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoListTeams",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/teams",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoListTeamsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoListTeamsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoListTeams: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoListTopics gets list of topics that a repository has
*/
func (a *Client) RepoListTopics(params *RepoListTopicsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoListTopicsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoListTopicsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoListTopics",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/topics",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoListTopicsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoListTopicsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoListTopics: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoMergePullRequest merges a pull request
*/
func (a *Client) RepoMergePullRequest(params *RepoMergePullRequestParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoMergePullRequestOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoMergePullRequestParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoMergePullRequest",
		Method:             "POST",
		PathPattern:        "/repos/{owner}/{repo}/pulls/{index}/merge",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoMergePullRequestReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoMergePullRequestOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoMergePullRequest: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoMigrate migrates a remote git repository
*/
func (a *Client) RepoMigrate(params *RepoMigrateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoMigrateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoMigrateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoMigrate",
		Method:             "POST",
		PathPattern:        "/repos/migrate",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoMigrateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoMigrateCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoMigrate: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoMirrorSync syncs a mirrored repository
*/
func (a *Client) RepoMirrorSync(params *RepoMirrorSyncParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoMirrorSyncOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoMirrorSyncParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoMirrorSync",
		Method:             "POST",
		PathPattern:        "/repos/{owner}/{repo}/mirror-sync",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoMirrorSyncReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoMirrorSyncOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoMirrorSync: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoNewPinAllowed returns if new issue pins are allowed
*/
func (a *Client) RepoNewPinAllowed(params *RepoNewPinAllowedParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoNewPinAllowedOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoNewPinAllowedParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoNewPinAllowed",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/new_pin_allowed",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoNewPinAllowedReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoNewPinAllowedOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoNewPinAllowed: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoPullRequestIsMerged checks if a pull request has been merged
*/
func (a *Client) RepoPullRequestIsMerged(params *RepoPullRequestIsMergedParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoPullRequestIsMergedNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoPullRequestIsMergedParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoPullRequestIsMerged",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/pulls/{index}/merge",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoPullRequestIsMergedReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoPullRequestIsMergedNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoPullRequestIsMerged: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoPushMirrorSync syncs all push mirrored repository
*/
func (a *Client) RepoPushMirrorSync(params *RepoPushMirrorSyncParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoPushMirrorSyncOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoPushMirrorSyncParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoPushMirrorSync",
		Method:             "POST",
		PathPattern:        "/repos/{owner}/{repo}/push_mirrors-sync",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoPushMirrorSyncReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoPushMirrorSyncOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoPushMirrorSync: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoSearch searches for repositories
*/
func (a *Client) RepoSearch(params *RepoSearchParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoSearchOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoSearchParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoSearch",
		Method:             "GET",
		PathPattern:        "/repos/search",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoSearchReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoSearchOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoSearch: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoSigningKey gets signing key gpg for given repository
*/
func (a *Client) RepoSigningKey(params *RepoSigningKeyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoSigningKeyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoSigningKeyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoSigningKey",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/signing-key.gpg",
		ProducesMediaTypes: []string{"text/plain"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoSigningKeyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoSigningKeyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoSigningKey: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoSubmitPullReview submits a pending review to an pull request
*/
func (a *Client) RepoSubmitPullReview(params *RepoSubmitPullReviewParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoSubmitPullReviewOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoSubmitPullReviewParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoSubmitPullReview",
		Method:             "POST",
		PathPattern:        "/repos/{owner}/{repo}/pulls/{index}/reviews/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoSubmitPullReviewReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoSubmitPullReviewOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoSubmitPullReview: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoTestHook tests a push webhook
*/
func (a *Client) RepoTestHook(params *RepoTestHookParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoTestHookNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoTestHookParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoTestHook",
		Method:             "POST",
		PathPattern:        "/repos/{owner}/{repo}/hooks/{id}/tests",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoTestHookReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoTestHookNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoTestHook: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoTrackedTimes lists a repo s tracked times
*/
func (a *Client) RepoTrackedTimes(params *RepoTrackedTimesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoTrackedTimesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoTrackedTimesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoTrackedTimes",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/times",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoTrackedTimesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoTrackedTimesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoTrackedTimes: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoTransfer transfers a repo ownership
*/
func (a *Client) RepoTransfer(params *RepoTransferParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoTransferAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoTransferParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoTransfer",
		Method:             "POST",
		PathPattern:        "/repos/{owner}/{repo}/transfer",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoTransferReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoTransferAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoTransfer: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoUnDismissPullReview cancels to dismiss a review for a pull request
*/
func (a *Client) RepoUnDismissPullReview(params *RepoUnDismissPullReviewParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoUnDismissPullReviewOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoUnDismissPullReviewParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoUnDismissPullReview",
		Method:             "POST",
		PathPattern:        "/repos/{owner}/{repo}/pulls/{index}/reviews/{id}/undismissals",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoUnDismissPullReviewReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoUnDismissPullReviewOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoUnDismissPullReview: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoUpdateAvatar updates avatar
*/
func (a *Client) RepoUpdateAvatar(params *RepoUpdateAvatarParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoUpdateAvatarNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoUpdateAvatarParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoUpdateAvatar",
		Method:             "POST",
		PathPattern:        "/repos/{owner}/{repo}/avatar",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoUpdateAvatarReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoUpdateAvatarNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoUpdateAvatar: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoUpdateFile updates a file in a repository
*/
func (a *Client) RepoUpdateFile(params *RepoUpdateFileParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoUpdateFileOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoUpdateFileParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoUpdateFile",
		Method:             "PUT",
		PathPattern:        "/repos/{owner}/{repo}/contents/{filepath}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoUpdateFileReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoUpdateFileOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoUpdateFile: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoUpdatePullRequest merges p r s base branch into head branch
*/
func (a *Client) RepoUpdatePullRequest(params *RepoUpdatePullRequestParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoUpdatePullRequestOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoUpdatePullRequestParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoUpdatePullRequest",
		Method:             "POST",
		PathPattern:        "/repos/{owner}/{repo}/pulls/{index}/update",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoUpdatePullRequestReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoUpdatePullRequestOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoUpdatePullRequest: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoUpdateTopics replaces list of topics for a repository
*/
func (a *Client) RepoUpdateTopics(params *RepoUpdateTopicsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoUpdateTopicsNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoUpdateTopicsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoUpdateTopics",
		Method:             "PUT",
		PathPattern:        "/repos/{owner}/{repo}/topics",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoUpdateTopicsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoUpdateTopicsNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoUpdateTopics: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RepoValidateIssueConfig returns the validation information for a issue config
*/
func (a *Client) RepoValidateIssueConfig(params *RepoValidateIssueConfigParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RepoValidateIssueConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRepoValidateIssueConfigParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "repoValidateIssueConfig",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/issue_config/validate",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RepoValidateIssueConfigReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RepoValidateIssueConfigOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repoValidateIssueConfig: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
TopicSearch searches topics via keyword
*/
func (a *Client) TopicSearch(params *TopicSearchParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*TopicSearchOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewTopicSearchParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "topicSearch",
		Method:             "GET",
		PathPattern:        "/topics/search",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &TopicSearchReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*TopicSearchOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for topicSearch: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
UpdateRepoSecret creates or update a secret value in a repository
*/
func (a *Client) UpdateRepoSecret(params *UpdateRepoSecretParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateRepoSecretCreated, *UpdateRepoSecretNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateRepoSecretParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateRepoSecret",
		Method:             "PUT",
		PathPattern:        "/repos/{owner}/{repo}/actions/secrets/{secretname}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateRepoSecretReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *UpdateRepoSecretCreated:
		return value, nil, nil
	case *UpdateRepoSecretNoContent:
		return nil, value, nil
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repository: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
UpdateRepoVariable updates a repo level variable
*/
func (a *Client) UpdateRepoVariable(params *UpdateRepoVariableParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateRepoVariableCreated, *UpdateRepoVariableNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateRepoVariableParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateRepoVariable",
		Method:             "PUT",
		PathPattern:        "/repos/{owner}/{repo}/actions/variables/{variablename}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateRepoVariableReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *UpdateRepoVariableCreated:
		return value, nil, nil
	case *UpdateRepoVariableNoContent:
		return nil, value, nil
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for repository: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
UserCurrentCheckSubscription checks if the current user is watching a repo
*/
func (a *Client) UserCurrentCheckSubscription(params *UserCurrentCheckSubscriptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UserCurrentCheckSubscriptionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUserCurrentCheckSubscriptionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "userCurrentCheckSubscription",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/subscription",
		ProducesMediaTypes: []string{"application/json", "text/html"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UserCurrentCheckSubscriptionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UserCurrentCheckSubscriptionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for userCurrentCheckSubscription: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
UserCurrentDeleteSubscription unwatches a repo
*/
func (a *Client) UserCurrentDeleteSubscription(params *UserCurrentDeleteSubscriptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UserCurrentDeleteSubscriptionNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUserCurrentDeleteSubscriptionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "userCurrentDeleteSubscription",
		Method:             "DELETE",
		PathPattern:        "/repos/{owner}/{repo}/subscription",
		ProducesMediaTypes: []string{"application/json", "text/html"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UserCurrentDeleteSubscriptionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UserCurrentDeleteSubscriptionNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for userCurrentDeleteSubscription: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
UserCurrentPutSubscription watches a repo
*/
func (a *Client) UserCurrentPutSubscription(params *UserCurrentPutSubscriptionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UserCurrentPutSubscriptionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUserCurrentPutSubscriptionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "userCurrentPutSubscription",
		Method:             "PUT",
		PathPattern:        "/repos/{owner}/{repo}/subscription",
		ProducesMediaTypes: []string{"application/json", "text/html"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UserCurrentPutSubscriptionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UserCurrentPutSubscriptionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for userCurrentPutSubscription: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
UserTrackedTimes lists a user s tracked times in a repo
*/
func (a *Client) UserTrackedTimes(params *UserTrackedTimesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UserTrackedTimesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUserTrackedTimesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "userTrackedTimes",
		Method:             "GET",
		PathPattern:        "/repos/{owner}/{repo}/times/{user}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UserTrackedTimesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UserTrackedTimesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for userTrackedTimes: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
